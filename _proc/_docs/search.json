[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nnot_equals\n\n not_equals (lhs:Union[sympy.core.expr.Expr,sympy.core.basic.Basic],\n             rhs:Union[sympy.core.expr.Expr,sympy.core.basic.Basic])\n\n\nsource\n\n\nequals\n\n equals (lhs:sympy.core.expr.Expr, rhs:sympy.core.expr.Expr)\n\n\nsource\n\n\nequation\n\n equation (expr:str)\n\n\nsource\n\n\nconstant\n\n constant (value:Union[int,float])\n\n\nsource\n\n\nvariable\n\n variable (name:str)\n\n\nsource\n\n\nmake_examples\n\n make_examples (domain:str, N:int, equation:str)\n\nFor a given domain and equation, select N examples and generate a list of N input-output pairs. Currently, the domain can be either ‘real’ or ‘integer’, and one variable is assumed.\n\nmake_examples('real', 10, 'x**2')\n\n[(-13, 169),\n (-29, 841),\n (-61, 3721),\n (-45, 2025),\n (95, 9025),\n (-14, 196),\n (-74, 5476),\n (-77, 5929),\n (-3, 9),\n (-76, 5776)]\n\n\n\nsource\n\n\nprove\n\n prove (goal:Union[sympy.core.relational.Equality,sympy.core.relational.Un\n        equality,sympy.core.relational.Relational], proof_func:Callable[..\n        .,Union[sympy.core.relational.Equality,sympy.core.relational.Unequ\n        ality,sympy.core.relational.Relational]], *args)\n\n\nsource\n\n\ncontradiction_proof\n\n contradiction_proof (proof)\n\nHere’s how to use a contradiction goal.\n\n# Start by defining your domain\narbitrary_x = variable(\"x\")\nexpression = arbitrary_x + 1\n\n# Then define your goal\ncontradiction_goal = not_equals(expression, arbitrary_x)\n\n@contradiction_proof\ndef proof_of_x_plus_one(x):\n    # Given x, Assume x + 1 = x is true for arbitrary_x\n    assumed_eq = equals(x + 1, x)\n\n    # Calculate x + 1\n    next = x + 1\n\n    # Observing x + 1 $\\neq$ x, we have reached a contradiction\n    return not_equals(next, assumed_eq.rhs)\n\n\\(x\\)\n\n\n\\(x + 1 \\neq x\\)\n\n\n\nprove(contradiction_goal, proof_of_x_plus_one, arbitrary_x)\n\n&lt;IPython.core.display.Latex object&gt;\n\n\n\\(x + 1 = x\\)\n\n\n&lt;IPython.core.display.Latex object&gt;\n\n\n&lt;IPython.core.display.Latex object&gt;\n\n\n\\(x + 1 \\neq x\\)\n\n\n\\(x + 1 = x\\)\n\n\n\\(x + 1 \\neq x\\)\n\n\n\\[\\text \\quad x + 1 \\neq x \\quad Q.E.D.\\]\n\n\nTrue"
  },
  {
    "objectID": "assistant.html",
    "href": "assistant.html",
    "title": "assistant",
    "section": "",
    "text": "The main goal here is to find paths for converting between different types in Python. The approaches discussed in this answer implement the following techniques:\n\nExploring class hierarchy (subclass and superclass relationships) between types.\nUsing a unification-like approach to find common types and conversion paths between types.\n\nPython is quite different from Lean, a theorem prover that finds paths between types for the purpose of proving mathematical statements. Because of it’s dynamic and less strict type system, we are instead trying to create dictionaries to hold and identify conversion functions for different pairs of types.\nThere are probably better/different approaches, this is just a proof of concept.\n\nTriavial unification like-approach\nI think this is closer to lean? 1. Define a set of conversion functions between different types. 2. Create a dictionary that maps pairs of types to their corresponding conversion functions. 3. Implement a unification function that takes two types and returns their common type, if one exists. 4. Implement a function that finds a conversion path between two expressions by unifying their types and using the conversion functions. 5. Use the function to find conversion paths between expressions.\nThis could be interesting and offers a more perscriptive way to work with this., but would require a lot of work to make useful.\n\n# Step 1: Define conversion functions\ndef convert_int_to_float(x: int) -&gt; float:\n    return float(x)\n\ndef convert_float_to_str(x: float) -&gt; str:\n    return str(x)\n\n# Step 2: Create a dictionary of conversion functions\nconversion_dict = {\n    (int, float): convert_int_to_float,\n    (float, str): convert_float_to_str,\n}\n\n# Step 3: Implement a unification function\ndef unify_types(type1, type2):\n    if type1 == type2:\n        return type1\n\n    if (type1, type2) in conversion_dict:\n        return type2\n\n    if (type2, type1) in conversion_dict:\n        return type1\n\n    return None\n\n# Step 4: Implement a function to find conversion paths\ndef find_conversion_path(expr1, expr2):\n    type1 = type(expr1)\n    type2 = type(expr2)\n\n    common_type = unify_types(type1, type2)\n    print(common_type)\n\n    if common_type is None:\n        return None\n\n    path = []\n\n    if type1 != common_type:\n        path.append(conversion_dict[(type1, common_type)])\n\n    if type2 != common_type:\n        path.append(conversion_dict[(common_type, type2)])\n\n    return path\n\n\n# Step 5: Use the function to find conversion paths between expressions\nexpr1 = 1\nexpr2 = 2.0\nconversion_path = find_conversion_path(expr1, expr2)\n\n&lt;class 'float'&gt;\n\n\n\ntest_eq(conversion_path[0], convert_int_to_float)\n\nSo, lots of work for kind of a simple thing. TBD if it’s work revisiting in the future.\n\n\nExploring class hierarchy\n\nDefine a function to find the least common ancestor (LCA) of two types in the class hierarchy.\nImplement a function to find a conversion path between two expressions by finding their LCA and using the LCA to define a conversion function.\n\nI don’t think 2 is generally possible.\n\n# Step 1: Define a function to find the least common ancestor of two types\ndef least_common_ancestor(type1, type2):\n    type1_superclasses = inspect.getmro(type1)\n    type2_superclasses = inspect.getmro(type2)\n    print(type1_superclasses)\n    print(type2_superclasses)\n\n    if type1 in type2_superclasses:\n        return type1\n    if type2 in type1_superclasses:\n        return type2\n\n    for superclass1 in type1_superclasses:\n        if superclass1 in type2_superclasses:\n            return superclass1\n\n    return None\n\n# Step 2: Implement a function to find a conversion path between two expressions\ndef find_conversion_path(expr1, expr2):\n    type1 = type(expr1)\n    type2 = type(expr2)\n\n    common_ancestor = least_common_ancestor(type1, type2)\n\n    if common_ancestor is None:\n        # No common ancestor found in the class hierarchy\n        return None\n    \n    def conversion_function(x):\n        return common_ancestor(x)\n\n    return conversion_function\n\n\n# example heirarchy - D is a subclass of C, which is a subclass of A\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(C): pass\n\nexpr1 = B()\nexpr2 = D()\n\nconversion_function = find_conversion_path(expr1, expr2)\n\n\nleast_common_ancestor(B, D)\n\n(&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)\n(&lt;class '__main__.D'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)\n\n\n__main__.A\n\n\n\n# conversion_function(expr1)\n\nTypeError: A() takes no arguments\n\n\nThe above function does not run, which is why it’s commented out.\nI don’t know if this is generally possible, but the least common ancestor approach is promising. There may be some element of hardcoded vs least common ancestor that would be useful here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "proofs",
    "section": "",
    "text": "This is a proofs validator to help students and hobbyists do mathematical thinking and problem solving.\nIt’s for when you buy a math book from the local used book store, so you have a piece of software to use to explore the mathematical concepts alongside you that’s fun and easy to use for anybody with a programming background.\nIt’s supposed to validate what you’re doing in a “black box” kind of manner, and try to offer you guardrails enough that you can spot your mistakes and feel reasonably more confident you know what you’re doing.\nNot perfectly confident, reasonably."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "proofs",
    "section": "Install",
    "text": "Install\npip install proofs"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "proofs",
    "section": "How to use",
    "text": "How to use\nLet’s start with something simple, first, let’s prove that “Given x, Assume x + 1 = x is false for all x”\nThis should be obvious, which makes is great to show how to approach a proof.\n\nDefine the problem\nLook at examples\nDecide on a proof strategy\nWrite the proof\n\n\n# Start by defining your domain\narbitrary_x = variable(\"x\")\nexpression = arbitrary_x + 1\n\n\nprint(expression)\n\nx + 1\n\n\n\n# select a few examples from the reals\nmake_examples('real', 3, expression)\n\n[(-92, -91), (59, 60), (80, 81)]\n\n\nHopefully these examples convice us that the statement is false. This suggests that we can prove it by contradiction.\n\n# Then define your goal\ncontradiction_goal = not_equals(expression, arbitrary_x)\n\n\n@contradiction_proof\ndef proof_of_x_plus_one(x):\n    # Given x, Assume x + 1 = x is true for arbitrary_x\n    assumed_eq = equals(x + 1, x)\n\n    # Calculate x + 1\n    next = x + 1\n\n    # Observing x + 1 $\\neq$ x, we have reached a contradiction\n    return not_equals(next, assumed_eq.rhs)\n\n#Select an arbitrary x from the domain\nprove(contradiction_goal, proof_of_x_plus_one, arbitrary_x)\n\n&lt;IPython.core.display.Latex object&gt;\n\n\n\\[x + 1 = x\\]\n\n\n&lt;IPython.core.display.Latex object&gt;\n\n\n\\[x + 1\\]\n\n\n&lt;IPython.core.display.Latex object&gt;\n\n\n\\[\\text \\quad x + 1 \\neq x \\quad Q.E.D.\\]\n\n\nTrue\n\n\nWith this, we get: 1. comments converted to latex, along with latex rendering of the math we are doing in python 2. validation that what we are returning from the proof matches the expected goal 3. some additional helpful errors"
  }
]